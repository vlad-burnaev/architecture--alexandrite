# Архитектурное решение по кешированию

## Анализ проблемы

### Текущая ситуация в MES

Операторы жалуются на низкую скорость работы:
- Первая страница MES долго грузится
- Показывает список заказов в работе по статусам
- Фильтр по статусам и пагинация не помогли

Корневая причина:
- Каждый раз при загрузке страницы → запрос в БД
- БД делает тяжелый SELECT с JOIN и фильтрами
- Один инстанс БД обрабатывает и чтение, и запись
- Нет read replicas
- Результат: страница грузится 5-10+ секунд

### Что нужно кешировать

Анализ запросов MES:

1. Список заказов по статусам
   - Операторы открывают эту страницу постоянно
   - Данные меняются не так часто (раз в минуты, не секунды)
   - Идеально подходит для кеширования

2. Агрегаты по статусам (дашборд)
   - Количество заказов в каждом статусе
   - Обновляется редко
   - Дорогой COUNT запрос

3. Детали заказа
   - Информация о конкретном заказе
   - Меняется реже чем список
   - Средний приоритет

Что НЕ кешировать:
- Операции записи (изменение статуса)
- Real-time данные (текущий оператор, работающий с заказом)
- Расчет стоимости (каждый раз новый)

---

## Мотивация

### Почему нужно кеширование

Проблема:
- MES загружается 5-10 секунд
- Операторы теряют время
- Важно видеть новые заказы быстро (от этого зависит вознаграждение)
- Негативно влияет на производительность

Кеширование решает:
- Загрузка страницы < 1 секунды (вместо 5-10)
- Снижение нагрузки на БД (меньше SELECT запросов)
- Лучший user experience для операторов
- Подготовка к масштабированию

### Элементы системы для кеширования

1. MES Application Server
   - Серверное кеширование через Redis
   - Кеш списка заказов
   - Кеш агрегатов

2. MES Frontend (опционально, низкий приоритет)
   - Клиентское кеширование в браузере
   - HTTP Cache headers
   - Local Storage для UI состояния

3. База данных
   - Query result cache (встроенный PostgreSQL)
   - Помогает но недостаточно

Фокус: серверное кеширование через Redis для MES

### Бизнес-ценность

Технические метрики:
- Response time: с 5-10s до < 1s (10x улучшение)
- Database load: -70-80% SELECT запросов
- Throughput: больше операторов могут работать одновременно

Бизнес-метрики:
- Производительность операторов: +20-30% (меньше ждут)
- Удовлетворенность операторов: выше (быстрая работа)
- Capacity: можем принять больше заказов

---

## Предлагаемое решение

### Выбор: серверное кеширование через Redis

Клиентское vs Серверное:

Клиентское кеширование (в браузере):
- Плюсы: нулевая нагрузка на сервер, мгновенный ответ
- Минусы: 
  - Каждый оператор имеет свой кеш (не видит обновления других)
  - Сложно инвалидировать (нельзя контролировать с сервера)
  - Не решает проблему нагрузки на БД
  - Stale data проблема

Серверное кеширование (Redis):
- Плюсы:
  - Единый кеш для всех операторов
  - Контролируемая инвалидация
  - Снижает нагрузку на БД
  - Consistent data
- Минусы:
  - Требует инфраструктуру (Redis)
  - Дополнительная сложность

Выбор: Серверное через Redis

Почему:
- Нужно снизить нагрузку на БД (главная проблема)
- Все операторы должны видеть актуальные данные
- Можем контролировать инвалидацию с сервера
- Redis быстрый и надежный

### Паттерн кеширования: Cache-Aside

Три основных паттерна:

1. Cache-Aside (Lazy Loading)
   - Приложение проверяет кеш
   - Если нет (cache miss) → читает из БД → кладет в кеш
   - Если есть (cache hit) → возвращает из кеша

2. Write-Through
   - При записи в БД → сразу обновляем кеш
   - Синхронная операция
   - Кеш всегда актуален

3. Refresh-Ahead
   - Асинхронно обновляем кеш до истечения TTL
   - Предугадываем что данные понадобятся

Выбор: Cache-Aside

Почему Cache-Aside подходит:

1. Простота реализации
   - Легко внедрить постепенно
   - Не требует изменения логики записи
   - Fail-safe: если Redis недоступен → читаем из БД

2. Подходит для read-heavy нагрузки
   - MES больше читает чем пишет
   - Операторы постоянно обновляют список
   - Редко меняют статусы

3. Гибкость
   - Можем кешировать только нужные данные
   - TTL контролирует актуальность

4. Экономия ресурсов
   - Кешируем только запрошенные данные (lazy)
   - Не тратим ресурсы на неиспользуемые данные

Почему НЕ Write-Through:

Недостатки для нашего случая:
- Усложняет логику записи
- Каждое изменение статуса → обновление кеша
- Если 10 заказов меняют статус → 10 операций в кеш
- Кешируются данные которые могут не запрашиваться
- Дополнительная latency на запись

Почему НЕ Refresh-Ahead:

Недостатки:
- Сложная реализация (predictive logic)
- Требует знать какие данные понадобятся
- Дополнительная нагрузка (постоянное обновление)
- Overkill для нашего случая

### Архитектура решения

Компоненты:

1. Redis Cluster
   - 3 ноды (1 master, 2 replicas)
   - Для отказоустойчивости
   - Хранение: in-memory
   - Persistence: RDB snapshot каждый час

2. MES Application
   - Интеграция с Redis
   - Cache-Aside логика
   - Fallback на БД при cache miss

3. MES Database (PostgreSQL)
   - Source of truth
   - Чтение только при cache miss

### Sequence Diagram: Чтение списка заказов

```
Operator → MES Frontend → MES API → Redis → PostgreSQL

Happy path (cache hit):
1. Operator: открывает страницу "Заказы в работе"
2. MES Frontend → MES API: GET /api/orders?status=MANUFACTURING_STARTED&page=1
3. MES API → Redis: GET orders:MANUFACTURING_STARTED:page:1
4. Redis → MES API: [cached data] (cache hit!)
5. MES API → MES Frontend: JSON response
6. MES Frontend: показывает список (< 1 секунды)

Cold path (cache miss):
1. Operator: открывает страницу
2. MES Frontend → MES API: GET /api/orders?status=MANUFACTURING_STARTED&page=1
3. MES API → Redis: GET orders:MANUFACTURING_STARTED:page:1
4. Redis → MES API: null (cache miss)
5. MES API → PostgreSQL: SELECT * FROM orders WHERE status = 'MANUFACTURING_STARTED' LIMIT 20 OFFSET 0
6. PostgreSQL → MES API: [data from database]
7. MES API → Redis: SET orders:MANUFACTURING_STARTED:page:1 [data] EX 60
8. Redis → MES API: OK
9. MES API → MES Frontend: JSON response
10. MES Frontend: показывает список (5-10 секунд первый раз, потом < 1 секунды)
```

### Sequence Diagram: Изменение статуса заказа

```
Operator → MES Frontend → MES API → PostgreSQL → RabbitMQ → Redis

1. Operator: берет заказ в работу (кнопка "Начать")
2. MES Frontend → MES API: POST /api/orders/12345/status
   Body: { "new_status": "MANUFACTURING_STARTED", "operator_id": "OP-001" }
3. MES API → PostgreSQL: BEGIN TRANSACTION
4. MES API → PostgreSQL: UPDATE orders SET status = 'MANUFACTURING_STARTED', operator_id = 'OP-001', updated_at = NOW() WHERE id = 12345
5. PostgreSQL → MES API: 1 row updated
6. MES API → PostgreSQL: COMMIT
7. MES API → RabbitMQ: PUBLISH order_status_changed { order_id: 12345, old_status: "SUBMITTED", new_status: "MANUFACTURING_STARTED" }
8. RabbitMQ → MES API: ACK
9. MES API → Redis: DEL orders:SUBMITTED:*
10. MES API → Redis: DEL orders:MANUFACTURING_STARTED:*
11. MES API → Redis: DEL order:12345
12. Redis → MES API: OK (кеш инвалидирован)
13. MES API → MES Frontend: { success: true }
14. MES Frontend: обновляет UI, показывает success

Следующий оператор открывает страницу:
15. Operator2 → MES Frontend → MES API: GET /api/orders?status=MANUFACTURING_STARTED&page=1
16. MES API → Redis: GET orders:MANUFACTURING_STARTED:page:1
17. Redis → MES API: null (cache miss, т.к. инвалидировали)
18. MES API → PostgreSQL: SELECT ... (fresh data с заказом 12345)
19. MES API → Redis: SET orders:MANUFACTURING_STARTED:page:1 [new data] EX 60
20. MES API → MES Frontend: JSON с обновленным списком
```

### Стратегия инвалидации кеша

Сравнение стратегий:

| Стратегия | Описание | Плюсы | Минусы | Подходит для MES? |
|-----------|----------|-------|--------|-------------------|
| **TTL (временная)** | Кеш живет N секунд, потом удаляется | Простая, автоматическая | Может показывать stale data | ✅ Частично |
| **Инвалидация по ключу** | При изменении → удаляем конкретный ключ | Точная, мгновенная | Нужно знать все затронутые ключи | ✅ Да |
| **Программная инвалидация** | При событии → удаляем группу ключей | Гибкая, покрывает связанные данные | Требует логики | ✅✅ Лучше всего |
| **Write-Through** | Обновляем кеш при записи | Всегда актуальный кеш | Усложняет запись, дополнительная latency | ❌ Нет |
| **Tag-based** | Теги на ключи, инвалидация по тегам | Гибкая группировка | Сложная реализация | ⚠️ Overkill |

Выбор: Комбинированная стратегия (TTL + Программная инвалидация)

### Реализация инвалидации

1. TTL как fallback (60 секунд)
   - Каждый кеш-ключ имеет TTL 60 секунд
   - Если забыли инвалидировать → кеш обновится через минуту
   - Защита от stale data

2. Программная инвалидация при изменении
   - Когда меняется статус заказа → удаляем кеши
   - Удаляем широко (все связанные страницы)

Ключи для инвалидации:

При изменении заказа #12345 со статуса SUBMITTED → MANUFACTURING_STARTED:

Удалить:
- `orders:SUBMITTED:*` - все страницы со статусом SUBMITTED (wildcard)
- `orders:MANUFACTURING_STARTED:*` - все страницы со статусом MANUFACTURING_STARTED
- `order:12345` - детали конкретного заказа
- `aggregates:orders_by_status` - агрегаты (пересчитать)

Почему широкая инвалидация:
- Гарантия актуальности
- Простота (не нужно вычислять какие именно страницы)
- Первый запрос после изменения → cache miss → свежие данные
- Последующие запросы → cache hit

Альтернатива (точная инвалидация):
- Удалять только конкретную страницу где был заказ
- Минус: сложно вычислить (заказ был на странице 3?)
- Минус: риск забыть какой-то ключ

### Кеш-ключи (schema)

```
orders:{status}:page:{page_number}
- Пример: orders:MANUFACTURING_STARTED:page:1
- TTL: 60 секунд
- Значение: JSON с массивом заказов

orders:{status}:filter:{filter_hash}:page:{page}
- Пример: orders:MANUFACTURING_STARTED:filter:a1b2c3:page:1
- Если есть дополнительные фильтры
- TTL: 60 секунд

order:{order_id}
- Пример: order:12345
- TTL: 60 секунд
- Значение: JSON с деталями заказа

aggregates:orders_by_status
- Пример: { "SUBMITTED": 45, "MANUFACTURING_STARTED": 23, ... }
- TTL: 30 секунд (обновляется чаще)
```

### Конфигурация Redis

Оценка размера:
- 1 страница заказов (20 заказов) = ~50KB JSON
- 10 страниц × 5 статусов = 50 страниц = 2.5MB
- Агрегаты = 1KB
- 1000 деталей заказов = 50MB
- Итого: ~100MB для активного кеша
- 4GB Redis = много запаса

### Мониторинг кеша

Метрики для отслеживания:

1. Cache Hit Ratio
   - Формула: hits / (hits + misses)
   - Цель: > 80%
   - Если низкий → TTL слишком маленький или частые инвалидации

2. Cache Response Time
   - Цель: < 10ms для Redis
   - Если медленно → проблемы с Redis

3. Database Load
   - До кеша: X queries/sec
   - После кеша: должно упасть на 70-80%

4. Page Load Time
   - До: 5-10 секунд
   - После: < 1 секунда

Алерты:
- Cache hit ratio < 70% → проверить стратегию
- Redis unavailable → алерт критичный
- Page load time > 2s → что-то не так

---

## План внедрения

### Фаза 1: Инфраструктура (неделя 1)

1. Развернуть Redis Cluster в Yandex Cloud
   - 3 ноды (1 master, 2 replicas)
   - Настроить persistence
   - Настроить мониторинг

2. Интегрировать Redis клиент в MES
   - Добавить NuGet: StackExchange.Redis
   - Конфигурация connection

### Фаза 2: Реализация (неделя 2)

3. Реализовать Cache-Aside для списка заказов
   - GetOrders с проверкой кеша
   - TTL 60 секунд

4. Реализовать инвалидацию
   - При изменении статуса → invalidate cache
   - Wildcard patterns для широкой инвалидации

### Фаза 3: Тестирование (неделя 3)

5. Нагрузочное тестирование
   - Проверить cache hit ratio
   - Измерить response time
   - Проверить что инвалидация работает

6. Тестирование failover
   - Что происходит если Redis недоступен
   - Fallback на БД должен работать

### Фаза 4: Раскатка (неделя 4)

7. Деплой в release окружение
8. Мониторинг метрик
9. Деплой в production
10. Мониторинг в production

Общий срок: 3-4 недели

Ресурсы: DevOps + 1-2 C# dev

---

## Метрики успеха

После внедрения кеширования:

1. Page Load Time: < 1 секунда (сейчас 5-10 секунд)
2. Cache Hit Ratio: > 80%
3. Database Load: -70% SELECT запросов
4. Operator Satisfaction: значительный рост
5. System Capacity: +50-100% больше операторов могут работать
6. Response Time p95: < 500ms
