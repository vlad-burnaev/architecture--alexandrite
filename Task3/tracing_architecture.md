# Архитектурное решение по трейсингу

## Анализ системы

### Критические точки жизненного цикла заказа

Где заказ может потеряться или зависнуть:

1. Internet Shop → RabbitMQ
   - Сообщение о создании заказа может не попасть в очередь
   - Проблема: нет подтверждения публикации

2. RabbitMQ → MES (расчет стоимости)
   - Сообщение может потеряться при доставке
   - MES может упасть во время обработки (2-30 минут)
   - Проблема: долгий расчет, нет visibility

3. MES → RabbitMQ (результат расчета)
   - Результат может не отправиться
   - Проблема: заказ рассчитан, но Shop не узнал

4. RabbitMQ → CRM (подтверждение заказа)
   - Сообщение может потеряться
   - CRM может быть недоступна
   - Проблема: заказ не попадет в производство

5. CRM → RabbitMQ (заказ подтвержден)
   - Уведомление MES о начале производства
   - Проблема: MES не узнает о подтверждении

6. MES внутри (производство)
   - Оператор берет заказ → смена статусов
   - Проблема: изменения статуса могут не сохраниться

7. MES → RabbitMQ → CRM (завершение производства)
   - Уведомление о готовности заказа
   - Проблема: CRM не узнает о готовности

8. 3D files storage
   - Загрузка файла может зависнуть
   - Файл может не связаться с заказом
   - Проблема: заказ без 3D модели не может быть обработан

9. API для B2B клиентов → Shop API → MES
   - Дополнительный hop, больше точек отказа
   - Проблема: еще сложнее отследить

### Системы, требующие трейсинга

- Internet Shop (Shop API)
- CRM (CRM API)
- MES (MES API)
- RabbitMQ (Messages Queue)
- 3D files storage (опционально, базовые операции)

---

## Список данных для трейсинга

### Обязательные данные в каждом span

1. Trace ID
   - Уникальный идентификатор всего пути заказа
   - Генерируется при создании заказа
   - Передается через все системы

2. Span ID
   - Уникальный идентификатор конкретной операции
   - Каждый сервис создает свои spans

3. Parent Span ID
   - Ссылка на родительскую операцию
   - Для построения дерева вызовов

4. Service Name
   - Имя сервиса (shop, crm, mes, rabbitmq)

5. Operation Name
   - Название операции (create_order, calculate_price, approve_order)

6. Timestamps
   - Start time - начало операции
   - End time - завершение операции
   - Duration - длительность (вычисляется)

7. Status
   - ok, error, timeout
   - HTTP status code для API вызовов

### Бизнес-данные (tags)

8. Order ID
   - Идентификатор заказа
   - Критично для поиска

9. Customer ID
   - Идентификатор клиента

10. Order Type
    - custom_3d, constructor, standard

11. Order Status
    - Текущий статус заказа
    - INITIATED, FILE_UPLOADED, SUBMITTED, PRICE_CALCULATED, etc.

12. API Key (для B2B)
    - Идентификатор B2B клиента
    - Для анализа проблем конкретного клиента

### Технические данные (tags)

13. User ID / Session ID
    - Для B2C клиентов

14. Request ID
    - Идентификатор HTTP запроса

15. Error Details
    - Error message
    - Error type
    - Stack trace

16. RabbitMQ специфичные данные
    - Queue name
    - Exchange name
    - Routing key
    - Message ID
    - Delivery tag

17. File информация (для загрузок)
    - File ID
    - File name
    - File size
    - File format (stl, obj, fbx)

18. Calculation details (для MES)
    - Model complexity (simple, medium, complex)
    - Polygon count
    - Expected duration
    - Actual duration

### Контекстные данные

19. Environment
    - dev, release, prod

20. Instance ID
    - Какой инстанс обработал запрос

21. Version
    - Версия приложения
    - Для корреляции с деплоями

---

## Мотивация

### Почему нужен трейсинг

Текущая ситуация в Александрите критична:
- Заказы теряются - клиенты жалуются на незавершенные заказы
- Невозможно найти где проблема - нет visibility через 3 системы
- Разбор инцидентов занимает часы/дни - приходится анализировать логи каждого сервиса отдельно
- B2B клиенты уходят - не могут отследить свои заказы

Трейсинг решает эту проблему, давая:
- Полную картину пути заказа через все системы
- Понимание где заказ зависает или теряется
- Быструю диагностику проблем (минуты вместо часов)
- Данные для оптимизации производительности

### Влияние на технические метрики

1. Mean Time To Detect (MTTD)
   - Сейчас: узнаем о проблеме от клиентов (часы/дни после возникновения)
   - С трейсингом: видим проблемы в реальном времени через алерты
   - Улучшение: с нескольких часов до нескольких минут

2. Mean Time To Resolve (MTTR)
   - Сейчас: разбор инцидента занимает часы (анализ логов всех систем)
   - С трейсингом: видим полный путь заказа за минуты
   - Улучшение: с часов до 15-30 минут

3. Error Rate Visibility
   - Сейчас: не знаем реальный % потерянных заказов
   - С трейсингом: видим сколько traces завершились ошибкой
   - Результат: точная метрика потери заказов

4. Performance Bottleneck Detection
   - Сейчас: не понятно где тормозит (MES расчет? RabbitMQ? БД?)
   - С трейсингом: видим где проводится больше всего времени
   - Результат: целенаправленная оптимизация

5. Distributed Transaction Success Rate
   - Сейчас: не знаем сколько заказов прошли весь путь успешно
   - С трейсингом: видим % успешных end-to-end transactions
   - Результат: SLI/SLO для качества сервиса

### Влияние на бизнес-метрики

1. Customer Satisfaction (CSAT/NPS)
   - Проблема: клиенты не получают заказы → негатив
   - С трейсингом: быстрое решение проблем → меньше жалоб
   - Ожидаемое улучшение: рост CSAT на 20-30%

2. B2B Retention Rate
   - Проблема: потеряли несколько крупных контрактов
   - С трейсингом: стабильный сервис → удержание клиентов
   - Ожидаемое улучшение: возврат к retention > 95%

3. Order Completion Rate
   - Проблема: неизвестный % потерянных заказов (клиенты жалуются)
   - С трейсингом: выявляем и исправляем проблемы → больше завершенных заказов
   - Ожидаемое улучшение: +5-10% completion rate = значительный рост выручки

4. Production Efficiency
   - Проблема: операторы не видят новые заказы вовремя
   - С трейсингом: выявляем задержки в доставке заказов в MES
   - Результат: операторы работают эффективнее

5. Time to Resolution для Support
   - Проблема: support не может помочь клиенту ("где мой заказ?")
   - С трейсингом: support видит где заказ и что с ним происходит
   - Результат: быстрое решение запросов клиентов

---

## Предлагаемое решение

### Выбор технологии

Jaeger - распределенный трейсинг на основе OpenTelemetry

Почему Jaeger:
- Open source (CNCF graduated project)
- Поддержка всех наших технологий (Java, C#, JavaScript)
- Высокая производительность (sampling, batching)
- UI для поиска и визуализации traces
- Совместимость с OpenTelemetry (стандарт индустрии)
- Опыт использования в больших компаниях (Uber, Red Hat, ...)

Альтернативы рассмотренные:
- Zipkin - менее функционален, меньше community
- AWS X-Ray - vendor lock-in, дороже
- Datadog APM - коммерческое решение, дорого

### Архитектура решения

Компоненты:

1. Jaeger Collector
   - Принимает traces от приложений
   - Валидирует и обрабатывает
   - Сохраняет в хранилище

2. Jaeger Storage Backend
   - Elasticsearch
   - Retention: 30 дней детальные traces, 90 дней агрегированные

3. Jaeger Query Service
   - API для поиска traces
   - Backend для UI

4. Jaeger UI
   - Web интерфейс для поиска и визуализации
   - Доступ для: DevOps, backend devs, QA, support, тимлид

5. OpenTelemetry Agents в каждом приложении
   - Internet Shop: OpenTelemetry Java SDK
   - CRM: OpenTelemetry Java SDK
   - MES: OpenTelemetry .NET SDK
   - Автоматическая инструментация HTTP, database queries

### Интеграция в приложения

Internet Shop (Java Spring Boot):
- Добавить OpenTelemetry Java SDK
- Автоматическая инструментация HTTP requests, database queries, RabbitMQ
- Кастомные spans: create_order, upload_3d_file, submit_order

CRM (Java Spring Boot):
- Аналогично Internet Shop
- Кастомные spans: receive_order_for_approval, approve_order, close_order

MES (C# ASP.NET):
- Добавить OpenTelemetry .NET SDK
- Автоматическая инструментация HTTP requests, database queries, RabbitMQ
- Кастомные spans: calculate_price, start_manufacturing, complete_manufacturing

### Передача контекста через RabbitMQ

Критично: Trace ID должен передаваться через RabbitMQ сообщения

Реализация:
- Publisher: внедряет trace context в message headers
- Consumer: извлекает trace context из headers и продолжает trace
- Результат: один trace проходит через всю цепочку Shop → RabbitMQ → MES → RabbitMQ → CRM

### Sampling Strategy

Проблема: трейсинг всех запросов создаст большую нагрузку

Решение: адаптивный sampling

1. Production:
   - Все ошибки: 100% (критично для диагностики)
   - Медленные запросы (> 5s): 100%
   - API запросы: 50% (высокая ценность)
   - Обычные запросы: 1-5%

2. Release:
   - 50% всех запросов

3. Dev:
   - 100% (для разработчиков)

### Use cases для команды

1. Support: "Где мой заказ #12345?"
   - Поиск по order_id в Jaeger UI
   - Видит: создан в Shop → отправлен в MES → застрял на calculate_price
   - Ответ клиенту: "Заказ в обработке, расчет стоимости занимает 15 минут"

2. DevOps: алерт "Orders stuck in MES"
   - Фильтр: service=mes AND duration > 30m
   - Видит: 20 traces зависли на calculate_price
   - Причина: MES перегружен
   - Действие: добавить инстанс MES

3. Backend dev: "Почему CRM тормозит?"
   - Фильтр: service=crm AND duration > 2s
   - Видит: большая часть времени в database query
   - Оптимизирует запрос

4. QA: тестирование новой фичи
   - Создает тестовый заказ
   - Находит trace по order_id
   - Проверяет все этапы прошли успешно

5. Бизнес-аналитик: сколько заказов успешно завершаются?
   - Query в Jaeger: traces с тегом operation=create_order
   - Фильтр по status=ok/error
   - Вычисляет success rate

---

## Компромиссы

### 1. 3D Files Storage (S3)

Проблема: S3-based storage - внешний сервис, сложно инструментировать

Компромисс:
- НЕ трейсим внутренние операции S3
- Трейсим только вызовы из Shop (upload_file, get_file)
- Достаточно для выявления проблем на стороне приложения

Почему:
- S3 SDK уже имеет встроенные метрики (CloudWatch)
- Стоимость трейсинга S3 операций высока (много мелких spans)
- Ценность низкая (S3 очень надежен)

### 2. Производительность и стоимость

Проблема: трейсинг добавляет overhead

Текущая оценка overhead:
- Latency: +1-5ms на запрос (сбор и отправка span)
- CPU: +2-5% на приложения
- Network: +10-50KB на trace
- Storage: ~1GB/день traces (при sampling 5%)

Компромисс:
- Использовать adaptive sampling (не 100% traces)
- Batch отправка spans (раз в 5 секунд)
- Асинхронная отправка (не блокирует основной поток)

Для Александрита overhead приемлем:
- Текущая нагрузка: ~500-1000 RPS суммарно
- Overhead: 5ms × 1000 RPS = 5 CPU-секунд/секунду = 5 cores
- У нас: 3 приложения × несколько инстансов = достаточно ресурсов

### 3. Проприетарный MES купленный с исходниками

Проблема: MES - купленное решение, код может быть сложным

Компромисс:
- Базовая инструментация: HTTP endpoints (легко - middleware)
- Детальная инструментация: только критичные операции (calculate_price, change_order_status)
- Внутренние детали MES: не трейсим (если слишком сложно)

Риск:
- Если MES код сложный/legacy → инструментация займет больше времени
- Оценка: 1-2 недели вместо нескольких дней

Митигация:
- Начать с автоматической инструментации (HTTP, DB)
- Добавить кастомные spans итеративно

### 4. Обучение команды

Проблема: команда не знакома с distributed tracing

Компромисс:
- Первые 2-4 недели: только DevOps и backend devs работают с Jaeger
- Постепенное обучение: QA, support
- Создание документации и примеров

Стоимость:
- 2-3 дня на обучение команды
- 1 неделя на адаптацию

### 5. Legacy код и технический долг

Проблема: в коде могут быть места без proper error handling

Компромисс:
- Трейсинг выявит эти места (traces с ошибками)
- Но fix потребует рефакторинга
- Приоритизировать: сначала критичные места

Ценность:
- Трейсинг сам по себе покажет где проблемы
- Даст roadmap для улучшений

---

## Безопасность

### 1. Аутентификация и авторизация для Jaeger UI

Jaeger UI должен быть защищен:

Решение:
- Развернуть OAuth2 Proxy перед Jaeger UI
- Интеграция с корпоративным LDAP/Active Directory
- Или использовать существующую SSO систему компании

Доступ:
- Разработчики (backend, frontend): read-only доступ к traces своих сервисов
- DevOps, SRE: full access ко всем traces
- Support: read-only к traces для помощи клиентам
- QA: read-only для тестирования
- Тимлид, продакт: read-only для мониторинга

### 2. Чувствительные данные в traces

Проблема: traces могут содержать персональные данные клиентов

Меры:
1. Не логировать в spans:
   - Номера кредитных карт
   - Пароли
   - Полные имена клиентов (только customer_id)
   - Email адреса
   - Адреса доставки

2. Использовать sanitization - хранить только идентификаторы, не персональные данные

3. Конфигурировать attribute filters:
   - Blacklist полей: password, credit_card, email
   - Автоматическое маскирование

### 3. Network Security

Меры:
1. TLS для передачи traces:
   - Приложения → Jaeger Collector: TLS 1.3
   - Jaeger UI → Query Service: TLS

2. Private network:
   - Jaeger компоненты в private subnet
   - Доступ только из корпоративной сети
   - VPN для удаленных сотрудников

3. Firewall rules:
   - Jaeger Collector: только от приложений (14250, 14268)
   - Jaeger UI: только через OAuth2 Proxy (443)
   - Elasticsearch: только от Jaeger компонентов

### 4. Data Retention и удаление

Политика хранения:
- 30 дней: детальные traces в Elasticsearch
- После 30 дней: автоматическое удаление

Compliance:
- GDPR: при удалении данных клиента → удалить traces с его customer_id
- Реализация: скрипт очистки traces по customer_id

### 5. Audit log для Jaeger UI

Логировать действия пользователей:
- Кто и когда искал traces
- По каким параметрам (order_id, customer_id)
- Для compliance и security audit

Реализация:
- Nginx access log перед Jaeger UI
- Или custom middleware в OAuth2 Proxy

### 6. Rate limiting для Jaeger API

Защита от DDoS и злоупотребления:
- Лимит: 100 запросов/минуту на пользователя
- Для API токенов (если есть): отдельные лимиты

### 7. Изоляция окружений

Dev/Release/Prod traces не должны смешиваться:

Решение 1 (рекомендуется для начала):
- Один Jaeger, но traces с тегом environment
- Фильтры в UI по environment

Решение 2 (для строгой изоляции):
- Отдельный Jaeger для prod
- Отдельный для dev/release

---

## План внедрения

### Фаза 1: Инфраструктура (неделя 1)

1. Развернуть Jaeger компоненты в Yandex Cloud
   - Jaeger Collector
   - Jaeger Query + UI
   - Использовать существующий Elasticsearch

2. Настроить OAuth2 Proxy для Jaeger UI

3. Настроить sampling strategy

### Фаза 2: Инструментация приложений (неделя 2-3)

4. Internet Shop
   - Добавить OpenTelemetry Java SDK
   - Автоматическая инструментация
   - Кастомные spans для create_order, upload_file

5. MES
   - Добавить OpenTelemetry .NET SDK
   - Кастомные spans для calculate_price
   - RabbitMQ consumer инструментация

6. CRM
   - Добавить OpenTelemetry Java SDK
   - Кастомные spans для approve_order

7. RabbitMQ context propagation
   - Настроить передачу trace context в headers

### Фаза 3: Тестирование (неделя 3-4)

8. E2E тестирование на dev окружении
9. Создать тестовый заказ и проверить trace
10. Убедиться что trace проходит через все системы

### Фаза 4: Раскатка в production (неделя 4)

11. Раскатка в prod с low sampling (1%)
12. Мониторинг overhead
13. Постепенное увеличение sampling до 5%

### Фаза 5: Обучение и документация (неделя 5)

14. Обучить команду работе с Jaeger UI
15. Создать runbook для типичных сценариев
16. Интеграция с алертингом

Общий срок: 4-5 недель

Ресурсы: DevOps + 2-3 backend dev

---

## Метрики успеха

После внедрения трейсинга:

1. Время диагностики проблем: < 30 минут (сейчас часы/дни)
2. Visibility заказов: 100% (сейчас 0%)
3. Order completion rate: +5-10%
4. MTTD для проблем с заказами: < 5 минут
5. MTTR: < 1 час для типичных проблем
6. Support time per ticket: -50%
